package com.styp.cenate.service.auth;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import com.styp.cenate.dto.*;
import com.styp.cenate.exception.WeakPasswordException;
import com.styp.cenate.model.Permiso;
import com.styp.cenate.model.Rol;
import com.styp.cenate.model.Usuario;
import com.styp.cenate.repository.PermisoRepository;
import com.styp.cenate.repository.UsuarioRepository;
import com.styp.cenate.security.service.JwtService;
import com.styp.cenate.service.auditlog.AuditLogService;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Data
public class AuthenticationServiceImpl implements AuthenticationService {

    private final UsuarioRepository usuarioRepository;
    private final PermisoRepository permisoRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final AuditLogService auditLogService;

    // =========================================================
    // üîê LOGIN (CORREGIDO: ya NO es read-only)
    // =========================================================
    @Override
    @Transactional
    public LoginResponse login(LoginRequest request) {
        log.info("üîê Intento de login para: {}", request.getUsername());

        Usuario user = usuarioRepository.findByNameUser(request.getUsername())
                .orElseGet(() -> buscarUsuarioPorCorreo(request.getUsername())
                        .orElseThrow(() -> new RuntimeException("Usuario o correo no encontrado")));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassUser())) {
            throw new RuntimeException("Usuario o contrase√±a incorrectos");
        }

        if (!user.isActive()) {
            throw new RuntimeException("La cuenta est√° inactiva o bloqueada.");
        }

        // Roles y permisos
        Set<Rol> roles = user.getRoles();
        List<Permiso> permisos = roles.stream()
                .flatMap(r -> r.getPermisos().stream())
                .distinct()
                .collect(Collectors.toList());

        // SUPERADMIN obtiene todos los permisos
        if (roles.stream().anyMatch(r -> r.getDescRol().equalsIgnoreCase("SUPERADMIN"))) {
            permisos = permisoRepository.findAll();
        }

        // Construcci√≥n de autoridades
        List<GrantedAuthority> authorities = new ArrayList<>();
        roles.forEach(rol -> authorities.add(new SimpleGrantedAuthority("ROLE_" + rol.getDescRol())));
        permisos.forEach(p -> authorities.add(new SimpleGrantedAuthority(p.getDescPermiso())));

        // Claims del token
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles.stream().map(Rol::getDescRol).toList());
        claims.put("permisos", permisos.stream().map(Permiso::getDescPermiso).toList());

        User userDetails = new User(user.getNameUser(), user.getPassUser(), authorities);
        String token = jwtService.generateToken(claims, userDetails);

        String rolPrincipal = roles.stream()
                .findFirst()
                .map(Rol::getDescRol)
                .orElse("SIN_ROL");

        // üßæ Registrar auditor√≠a del login exitoso
        try {
            auditLogService.registrarEvento(
                    user.getNameUser(),
                    "LOGIN",
                    "AUTH",
                    "Usuario inici√≥ sesi√≥n exitosamente",
                    "INFO",
                    "SUCCESS"
            );
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è No se pudo registrar el log de login: {}", e.getMessage());
        }

        return LoginResponse.builder()
                .token(token)
                .username(user.getNameUser())
                .nombreCompleto(user.getNombreCompleto())
                .rolPrincipal(rolPrincipal)
                .roles(roles.stream().map(Rol::getDescRol).toList())
                .permisos(permisos.stream().map(Permiso::getDescPermiso).toList())
                .build();
    }

    // =========================================================
    // üßç CREAR USUARIO
    // =========================================================
    @Override
    @Transactional
    public UsuarioResponse createUser(UsuarioCreateRequest request) {
        log.info("üßç Registrando nuevo usuario: {}", request.getUsername());

        if (usuarioRepository.existsByNameUser(request.getUsername())) {
            throw new RuntimeException("El nombre de usuario ya existe");
        }

        if (!isPasswordSecure(request.getPassword())) {
            throw new WeakPasswordException(
                    "La contrase√±a debe tener al menos 8 caracteres, incluir may√∫sculas, min√∫sculas, n√∫meros y un s√≠mbolo."
            );
        }

        Usuario user = new Usuario();
        user.setNameUser(request.getUsername());
        user.setPassUser(passwordEncoder.encode(request.getPassword()));
        user.setStatUser("A");

        Usuario savedUser = usuarioRepository.save(user);

        // üßæ Registrar auditor√≠a
        try {
            auditLogService.registrarEvento(
                    savedUser.getNameUser(),
                    "CREATE_USER",
                    "AUTH",
                    "Usuario creado exitosamente",
                    "INFO",
                    "SUCCESS"
            );
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è No se pudo registrar el log de creaci√≥n de usuario: {}", e.getMessage());
        }

        return UsuarioResponse.builder()
                .idUser(savedUser.getIdUser())
                .username(savedUser.getNameUser())
                .estado(savedUser.getStatUser())
                .message("Usuario registrado exitosamente")
                .build();
    }

    // =========================================================
    // üîë CAMBIO DE CONTRASE√ëA
    // =========================================================
    @Override
    @Transactional
    public void changePassword(String username, String currentPassword, String newPassword, String confirmPassword) {
        log.info("üß© Cambio de contrase√±a solicitado para: {}", username);

        Usuario user = usuarioRepository.findByNameUser(username)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        if (!passwordEncoder.matches(currentPassword, user.getPassUser())) {
            throw new RuntimeException("La contrase√±a actual es incorrecta");
        }

        if (!newPassword.equals(confirmPassword)) {
            throw new RuntimeException("La nueva contrase√±a y su confirmaci√≥n no coinciden");
        }

        if (passwordEncoder.matches(newPassword, user.getPassUser())) {
            throw new RuntimeException("La nueva contrase√±a no puede ser igual a la actual");
        }

        if (!isPasswordSecure(newPassword)) {
            throw new WeakPasswordException(
                    "La nueva contrase√±a debe tener al menos 8 caracteres, incluir may√∫sculas, min√∫sculas, n√∫meros y un s√≠mbolo."
            );
        }

        user.setPassUser(passwordEncoder.encode(newPassword));
        usuarioRepository.save(user);

        // üßæ Registrar auditor√≠a del cambio de contrase√±a
        try {
            auditLogService.registrarEvento(
                    username,
                    "CHANGE_PASSWORD",
                    "AUTH",
                    "Cambio de contrase√±a exitoso",
                    "INFO",
                    "SUCCESS"
            );
        } catch (Exception e) {
            log.warn("‚ö†Ô∏è No se pudo registrar el log de cambio de contrase√±a: {}", e.getMessage());
        }

        log.info("‚úÖ Contrase√±a actualizada exitosamente para {}", username);
    }

    // =========================================================
    // üîé M√âTODOS AUXILIARES
    // =========================================================
    private Optional<Usuario> buscarUsuarioPorCorreo(String correo) {
        log.info("üîé Buscando usuario por correo: {}", correo);
        try {
            boolean existe = usuarioRepository.existsByAnyEmail(correo);
            if (!existe) return Optional.empty();
            return usuarioRepository.findAll().stream()
                    .filter(u -> correo.equalsIgnoreCase(obtenerCorreoUsuario(u)))
                    .findFirst();
        } catch (Exception e) {
            log.error("‚ö†Ô∏è Error buscando usuario por correo: {}", e.getMessage());
            return Optional.empty();
        }
    }

    private String obtenerCorreoUsuario(Usuario u) {
        return null; // pendiente de integraci√≥n con tablas de personal
    }

    private boolean isPasswordSecure(String password) {
        return password.length() >= 8 &&
                password.matches(".*[A-Z].*") &&
                password.matches(".*[a-z].*") &&
                password.matches(".*\\d.*") &&
                password.matches(".*[!@#$%^&*(),.?\":{}|<>].*");
    }
}
