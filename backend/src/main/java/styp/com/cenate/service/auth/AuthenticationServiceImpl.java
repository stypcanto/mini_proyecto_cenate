package styp.com.cenate.service.auth;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import styp.com.cenate.dto.*;
import styp.com.cenate.exception.WeakPasswordException;
import styp.com.cenate.model.Usuario;
import styp.com.cenate.repository.UsuarioRepository;
import styp.com.cenate.security.service.JwtService;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthenticationServiceImpl implements AuthenticationService {

    private final UsuarioRepository usuarioRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;

    // =========================================================
    // üîê LOGIN
    // =========================================================
    @Override
    @Transactional(readOnly = true)
    public LoginResponse login(LoginRequest request) {
        log.info("üîê Login solicitado para usuario: {}", request.getUsername());

        Usuario user = usuarioRepository.findByNameUser(request.getUsername())
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        if (!passwordEncoder.matches(request.getPassword(), user.getPassUser())) {
            throw new RuntimeException("Usuario o contrase√±a incorrectos");
        }

        if (!"ACTIVO".equalsIgnoreCase(user.getStatUser())) {
            throw new RuntimeException("La cuenta est√° inactiva o bloqueada.");
        }

        List<GrantedAuthority> authorities = new ArrayList<>();
        user.getRoles().forEach(rol -> {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + rol.getDescRol()));
            rol.getPermisos().forEach(permiso ->
                    authorities.add(new SimpleGrantedAuthority(permiso.getDescPermiso()))
            );
        });

        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", user.getRoles().stream()
                .map(r -> r.getDescRol()).collect(Collectors.toSet()));
        claims.put("permisos", user.getRoles().stream()
                .flatMap(r -> r.getPermisos().stream())
                .map(p -> p.getDescPermiso())
                .collect(Collectors.toSet()));

        User userDetails = new User(user.getNameUser(), user.getPassUser(), authorities);
        String token = jwtService.generateToken(claims, userDetails);

        return LoginResponse.builder()
                .type("Bearer")
                .token(token)
                .userId(user.getIdUser())
                .username(user.getNameUser())
                .roles(user.getRoles().stream()
                        .map(r -> r.getDescRol()).collect(Collectors.toSet()))
                .permisos(user.getRoles().stream()
                        .flatMap(r -> r.getPermisos().stream())
                        .map(p -> p.getDescPermiso())
                        .collect(Collectors.toSet()))
                .message("Login exitoso")
                .build();
    }

    // =========================================================
    // üßç CREAR USUARIO MANUAL (solo para pruebas o admin)
    // =========================================================
    @Override
    @Transactional
    public UsuarioResponse createUser(UsuarioCreateRequest request) {
        log.info("üßç Registrando nuevo usuario: {}", request.getUsername());

        if (usuarioRepository.existsByNameUser(request.getUsername())) {
            throw new RuntimeException("El nombre de usuario ya existe");
        }

        if (!isPasswordSecure(request.getPassword())) {
            throw new WeakPasswordException(
                    "La contrase√±a debe tener al menos 8 caracteres, incluir may√∫sculas, min√∫sculas, n√∫meros y un s√≠mbolo."
            );
        }

        Usuario user = new Usuario();
        user.setNameUser(request.getUsername());
        user.setPassUser(passwordEncoder.encode(request.getPassword()));
        user.setStatUser("ACTIVO");

        Usuario savedUser = usuarioRepository.save(user);

        return UsuarioResponse.builder()
                .idUser(savedUser.getIdUser())
                .username(savedUser.getNameUser())
                .estado(savedUser.getStatUser()) // üîπ Cambiado de statUser() ‚Üí estado()
                .message("Usuario registrado exitosamente")
                .build();
    }

    // =========================================================
    // üîë CAMBIO DE CONTRASE√ëA
    // =========================================================
    @Override
    @Transactional
    public void changePassword(String username, String currentPassword, String newPassword, String confirmPassword) {
        log.info("üß© Cambio de contrase√±a solicitado para: {}", username);

        Usuario user = usuarioRepository.findByNameUser(username)
                .orElseThrow(() -> new RuntimeException("Usuario no encontrado"));

        if (!passwordEncoder.matches(currentPassword, user.getPassUser())) {
            throw new RuntimeException("La contrase√±a actual es incorrecta");
        }

        if (!newPassword.equals(confirmPassword)) {
            throw new RuntimeException("La nueva contrase√±a y su confirmaci√≥n no coinciden");
        }

        if (passwordEncoder.matches(newPassword, user.getPassUser())) {
            throw new RuntimeException("La nueva contrase√±a no puede ser igual a la actual");
        }

        if (!isPasswordSecure(newPassword)) {
            throw new WeakPasswordException(
                    "La nueva contrase√±a debe tener al menos 8 caracteres, incluir may√∫sculas, min√∫sculas, n√∫meros y un s√≠mbolo."
            );
        }

        user.setPassUser(passwordEncoder.encode(newPassword));
        usuarioRepository.save(user);

        log.info("‚úÖ Contrase√±a actualizada exitosamente para {}", username);
    }

    // =========================================================
    // üß† Validaci√≥n de seguridad de contrase√±a
    // =========================================================
    private boolean isPasswordSecure(String password) {
        return password.length() >= 8 &&
                password.matches(".*[A-Z].*") &&
                password.matches(".*[a-z].*") &&
                password.matches(".*\\d.*") &&
                password.matches(".*[!@#$%^&*(),.?\":{}|<>].*");
    }
}